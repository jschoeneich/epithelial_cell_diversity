---
title: "dorothea_ages_separate"
author: "Johannes Sch√∂neich"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(circlize)
library(ComplexHeatmap)
library(cowplot)
library(glue)
library(grid)
library(LR2TF)
library(maditr)
library(openxlsx)
library(patchwork)
library(RColorBrewer)
library(Scillus)
library(scCustomize)
library(Seurat)
library(stringr)
library(tidyverse)
library(decoupleR)
library(dorothea)

harddrive <- "H:/231248/NTFS_3.64TB"

analysis_folder <- file.path(harddrive,"dorothea_2025/all_stages")
dir.create(analysis_folder)

source(file.path(harddrive,"scrna_datasets/save_load_helper.R"))
source(file.path(harddrive,"helper_functions.R"))
source(file.path(harddrive,"dorothea_tf_analysis/lr2tf_function.R"))

plots_folder <- file.path(analysis_folder,"analysis/plots")
charts_folder <- file.path(analysis_folder,"analysis/charts/")
dir.create(plots_folder,recursive = TRUE)
dir.create(charts_folder,recursive = TRUE)
```

```{r}
scrna_folder <- file.path(harddrive,"scrna_datasets",
                          "scrna_full_both_d25_mito_filter_inf",
                          "scrna_full_both_d25_mito100_inf")

cluster_use <- "int_0.3_broad"

scrna <- load_object(
  file.path(scrna_folder,"scrna_full_filtered_uninf.Rds")
)
Idents(scrna) <- "int_0.3_broad"
scrna2 <- subset(scrna,idents = "Tuft",invert = TRUE)
# 
# Idents(scrna2) <- "name"
# scrna2 <- subset(scrna2,idents = "d05i",invert = TRUE)
# scrna2$name <- droplevels(as.factor(scrna2$name))
```

```{r, eval=FALSE}
net <- read.csv(file.path(charts_folder,"dorothea_regulons_ABCD.csv"))

# Extract the normalized log-transformed counts
mat <- as.matrix(scrna2@assays$RNA@layers$data)

# Run ulm
acts <- run_ulm(mat = mat, net = net, 
                .source = 'source', .target = 'target',
                .mor = 'weight', minsize = 5)
acts
write.csv(acts,file.path(charts_folder,"acts_decoupler_scrna_size5.csv"),
          row.names = FALSE)
```

```{r}
DefaultAssay(scrna2) <- "RNA"
dir.create(file.path(analysis_folder,"analysis/broad"))
parameters <- list("out_path" = file.path(analysis_folder,"analysis/broad"),
                   reg = file.path(charts_folder,"dorothea_regulons_ABCD.csv"),
                   "organism" = "mouse",
                   "celltype" = "int_0.3_broad", 
                   #name of the meta data field defining cell identities
                   "condition" = "stage", 
                   #name of the meta data field defining conditions
                   "comparison_list" = list(c("d01","d25")), 
                   #list of condition comparison to consider
                   "logfc" = 1,
                   "pval" = 0.05, 
                   #thresholds for logfc and pval used in 
                   # differential transcription factor analysis
                   "num_cell_filter" = 0) #define the minimum number of cells
                    #per cluster to perform the analysis on

results <- tf_activity_analysis_v2(seuratobject = scrna2,
                                       tf_activities =
                    file.path(charts_folder,"acts_decoupler_scrna_size5.csv"),
                                       arguments_list = parameters)

save_object(results,file.path(analysis_folder,"results_lr2tf_all_stages2025_broad.Rds"))
```

```{r}
dir.create(file.path(analysis_folder,"analysis/broad_TA"))
parameters <- list("out_path" = file.path(analysis_folder,"analysis/broad_TA"),
                   reg = file.path(charts_folder,"dorothea_regulons_ABCD.csv"),
                   "organism" = "mouse",
                   "celltype" = "int_0.3_broad_TA", 
                   #name of the meta data field defining cell identities
                   "condition" = "stage", 
                   #name of the meta data field defining conditions
                   "comparison_list" = list(c("d01","d25")), 
                   #list of condition comparison to consider
                   "logfc" = 1,
                   "pval" = 0.05, 
                   #thresholds for logfc and pval used in 
                   # differential transcription factor analysis
                   "num_cell_filter" = 0) #define the minimum number of cells
                    #per cluster to perform the analysis on

results <- tf_activity_analysis_v2(seuratobject = scrna2,
                                       tf_activities =
                    file.path(charts_folder,
                              "acts_decoupler_scrna_size5.csv"),
                                       arguments_list = parameters)

save_object(results,file.path(analysis_folder,
                              "results_lr2tf_all_stages2025_broad.Rds"))
```


```{r}
condition <- "d01"

condition_folder <- file.path(analysis_folder,condition)

```

# Calculate transcription factor heatmap inside condition 
```{r}
all_conditions <- c("d01","d05","d10","d25")

analysis_folder <- file.path(analysis_folder,"analysis/TF_results")

for (condition in all_conditions) {
condition_folder <- file.path(analysis_folder,condition)

seuratobject.markers <- read.csv(
  file.path(condition_folder,
            glue("all_specificmarker__{condition}.csv")
            )
  )

viper_scores <- read.csv(file.path(condition_folder,
                                   glue("tf_scores_{condition}.csv")),
                         row.names = 1
        )

# condition_hm <- calculate_tf_condition_heatmap(
#   seuratobject.markers = seuratobject.markers,
#   viper_scores = viper_scores,
#   title = condition
#   #title = element_blank()
#   )
# 
# size <- calc_ht_size(condition_hm)

# condition subset top 5

seurat.markers_top5 <- seuratobject.markers %>% arrange(p_val_adj) %>%
  group_by(cluster) %>% slice_head(n = 5)

viper_scores_top5 <- viper_scores %>% 
  filter(rownames(viper_scores) %in% seurat.markers_top5$gene)

condition_hm_top5 <- calculate_tf_condition_heatmap(
  seuratobject.markers = seurat.markers_top5,
  viper_scores = viper_scores_top5,
  title = condition
  #title = element_blank()
  )

size <- calc_ht_size(condition_hm_top5)

save_ggplot_formats(
  plt = condition_hm_top5,
  base_plot_dir = plots_folder,
  plt_name = glue("tf_activity_top5_{condition}_same_max"),
  width = size[1], height = size[2],
  plot_obj = "heatmap"
  )
}
```

# upset plots
```{r}
dorothea_markers_list <- lapply(all_conditions,function(x){NULL})
names(dorothea_markers_list) <- all_conditions

for(condition in all_conditions){
  condition_folder <- file.path(analysis_folder,condition)
  
  dorothea_markers_list[[condition]] <- read.csv(
    file.path(condition_folder,
              glue("significant_cluster_tf_results_{condition}.csv")
              ), row.names = 1
    )
  dorothea_markers_list[[condition]]$cluster <-
    as.factor(dorothea_markers_list[[condition]]$cluster
              )
}

dorothea_markers_list_split <-
  lapply(dorothea_markers_list,function(x){split(x,x$cluster)})
```

```{r}
mat <- make_comb_mat(dorothea_genes)

# Create the UpSet plot
us_plot <- UpSet(mat,
      top_annotation = upset_top_annotation(mat, add_numbers = TRUE),
      right_annotation = upset_right_annotation(mat, add_numbers = TRUE),
      comb_order = rev(order(comb_size(mat))),set_order = all_conditions,
      bg_col = "white"
      )
```

```{r}
# Flatten the nested list and extract only the gene columns
collapsed_list <- unlist(
  lapply(names(dorothea_markers_list_split), function(day) {
    lapply(names(dorothea_markers_list_split[[day]]), function(cluster) {
      genes <- dorothea_markers_list_split[[day]][[cluster]] %>% 
        #filter(p_val_adj < 0.05 & abs(avg_log2FC) > 1 ) %>% 
        pull(gene)
      names(genes) <- NULL  # Remove any stray names from the vector
      return(genes)
    })
  }), recursive = FALSE
)

# Create the new names by combining day and cluster (e.g., "d01_eec")
names(collapsed_list) <- unlist(
  lapply(names(dorothea_markers_list_split), function(day) {
    paste0(day, "_", tolower(names(dorothea_markers_list_split[[day]])))
  })
)

mat <- make_comb_mat(collapsed_list)

# Create the UpSet plot
us_plot <- UpSet(mat,
      top_annotation = upset_top_annotation(mat, add_numbers = TRUE),
      right_annotation = upset_right_annotation(mat, add_numbers = TRUE),
      comb_order = rev(order(comb_size(mat))),
      set_order = names(collapsed_list),
      bg_col = "white"
      )

mat5 <- mat[comb_size(mat) >= 5]

us_plot_size5 <- UpSet(mat5,
      top_annotation = upset_top_annotation(mat5, add_numbers = TRUE),
      right_annotation = upset_right_annotation(mat5, add_numbers = TRUE),
      comb_order = rev(order(comb_size(mat5))),
      set_order = names(collapsed_list),
      bg_col = "white"
      )

```

```{r}
save_ggplot_formats(
  plt = us_plot,
  base_plot_dir = plots_folder,
  plot_obj = "not_gg",
  plt_name = "upset_transcription_factors",
  width = 12, height = 4
)

save_ggplot_formats(
  plt = us_plot_size5,
  base_plot_dir = plots_folder,
  plot_obj = "not_gg",
  plt_name = "upset_transcription_factors_min_size_5",
  width = 10, height = 4
)
```

```{r}
# Get the set names in the order specified in your plot
set_names <- names(collapsed_list)

# Get all combination binary strings
comb_binary <- comb_name(mat)

# Order combinations by reversed size (to have highest to the left)
comb_sizes <- comb_size(mat)
comb_binary_ordered <- comb_binary[rev(order(comb_sizes))]

# Function to map binary string to set names
binary_to_sets <- function(binary, set_names) {
  binary_vec <- as.numeric(strsplit(binary, "")[[1]])
  active_sets <- set_names[which(binary_vec == 1)]
  return(active_sets)
}

# Extract genes for each combination in the ordered list
combination_genes <- lapply(comb_binary_ordered, function(binary) {
  extract_comb(mat,binary)
})

# Name the list with human-readable combinations
names(combination_genes) <- sapply(comb_binary_ordered, function(binary) {
  active_sets <- binary_to_sets(binary, set_names)
  paste(active_sets, collapse = "_and_")
})
```

```{r}
# Determine the maximum length
max_length <- max(sapply(combination_genes, length))

# Fill shorter columns with NA
df <- data.frame(lapply(combination_genes, function(x) {
  length(x) <- max_length  # Extend to max length
  return(x)
}))

write.xlsx(df,file.path(charts_folder,"upsetplot_genes.xlsx"))
```

```{r}
#TF subset lists abs.ent., eec and gob+pan

ent_list <- collapsed_list[grep("abs.ent.",names(collapsed_list))]
gob_list <- collapsed_list[grep("gob",names(collapsed_list))]
eec_list <- collapsed_list[grep("eec",names(collapsed_list))]

calculate_and_save_upset <- function(comb_list, Name,
                                     plots_folder, charts_folder,
                                     min_size = 0){
  mat <- make_comb_mat(comb_list)
  mat <- mat[comb_size(mat) >= min_size]

  # Create the UpSet plot
  us_plot <- UpSet(mat,
      top_annotation = upset_top_annotation(mat, add_numbers = TRUE),
      right_annotation = upset_right_annotation(mat, add_numbers = TRUE),
      comb_order = rev(order(comb_size(mat))),
      set_order = names(comb_list),
      bg_col = "white"
      )

  save_ggplot_formats(
    plt = us_plot,
    base_plot_dir = plots_folder,
    plot_obj = "not_gg",
    plt_name = glue("upset_transcription_factors_{Name}"),
    width = 10, height = 4
  )
  
  # Get the set names in the order specified in the plot
set_names <- names(comb_list)

# Get all combination binary strings
comb_binary <- comb_name(mat)

# Order combinations by reversed size (to have highest to the left)
comb_sizes <- comb_size(mat)
comb_binary_ordered <- comb_binary[rev(order(comb_sizes))]

# Function to map binary string to set names
binary_to_sets <- function(binary, set_names) {
  binary_vec <- as.numeric(strsplit(binary, "")[[1]])
  active_sets <- set_names[which(binary_vec == 1)]
  return(active_sets)
}

# Extract genes for each combination in the ordered list
combination_genes <- lapply(comb_binary_ordered, function(binary) {
  extract_comb(mat,binary)
})

# Name the list with human-readable combinations
names(combination_genes) <- sapply(comb_binary_ordered, function(binary) {
  active_sets <- binary_to_sets(binary, set_names)
  paste(active_sets, collapse = "_and_")
})

# Determine the maximum length
max_length <- max(sapply(combination_genes, length))

# Fill shorter columns with NA
df <- data.frame(lapply(combination_genes, function(x) {
  length(x) <- max_length  # Extend to max length
  return(x)
}))

write.xlsx(df,file.path(charts_folder,glue("upsetplot_genes_{Name}.xlsx")))

}

calculate_and_save_upset(ent_list,
                         Name = "enterocyte_minsize5",
                         plots_folder = plots_folder,
                         charts_folder = charts_folder,
                         min_size = 5)

calculate_and_save_upset(eec_list,
                         Name = "eec_minsize5",
                         plots_folder = plots_folder,
                         charts_folder = charts_folder,
                         min_size = 5)

calculate_and_save_upset(gob_list,
                         Name = "goblet_paneth_minsize5",
                         plots_folder = plots_folder,
                         charts_folder = charts_folder,
                         min_size = 5)
```

```{r}
#presence absence heatmap absorptive enterocytes
#idea: we want for each subtype the top 15 TFs and see if they are present absent ()

all_markers <- lapply(dorothea_markers_list, function(df) {
  df %>% filter(!cluster %in% c("Stem", "TA"))
})


top15_combined <- dorothea_markers_list %>%
  imap_dfr(~ .x %>%
             filter(!cluster %in% c("Stem", "TA")) %>%
             group_by(cluster) %>%
             arrange(desc(z_score)) %>%
             slice_head(n = 15) %>%
             mutate(timepoint = .y))
```

```{r}
# Use full table for presence_absence and then filter down to top 15 per cluster

# Combine all data frames into one
combined_markers <- bind_rows(
  lapply(names(all_markers), function(tp) {
    df <- all_markers[[tp]]
    df$timepoint <- tp
    return(df)
  })
)

# Generate presence matrix for each cluster
presence_matrices <- combined_markers %>%
  mutate(presence = 1) %>%
  select(gene, cluster, timepoint, presence) %>%
  pivot_wider(names_from = timepoint, values_from = presence, 
              values_fill = 0)

# Enhanced heatmap plotting function for a given cluster
plot_cluster_heatmap <- function(cluster_name, color_palette = NULL) {
  
  top15_combined_tmp <- top15_combined %>% filter(cluster == cluster_name)
  
  # Prepare data
  cluster_data <- presence_matrices %>%
    filter(cluster == cluster_name & gene %in% top15_combined_tmp$gene) %>%
    ungroup() %>%
    select(-cluster)
  
  mat <- as.matrix(cluster_data[,-1])
  rownames(mat) <- cluster_data$gene
  
  n_cols <- ncol(mat)
  
  # default palette if none provided
  if (is.null(color_palette)) {
    color_palette <- rep("#1f77b4", n_cols)
  } else {
    if (length(color_palette) != n_cols) {
      stop("Length of color_palette must match number of columns")
    }
  }
  
  # cell_fun: colors each cell based on its value and column
  ht <- Heatmap(
    mat,
    name = "Presence",
    show_row_names = TRUE,
    show_column_names = TRUE,
    column_title = paste("Cluster:", cluster_name),
    row_names_gp = gpar(fontsize = 5),
    row_names_rot = 45,
    column_names_gp = gpar(fontsize = 5),
    show_heatmap_legend = FALSE,
    cluster_columns = FALSE,
    rect_gp = gpar(col = "black", lwd = 0.5),
    width = unit(n_cols * 2.5, "mm"),
    height = unit(nrow(mat) * 2.5, "mm"),
    cell_fun = function(j, i, x, y, width, height, fill) {
      val <- mat[i, j]
      col <- ifelse(val == 1, color_palette[j], "white")
      grid.rect(x = x, y = y, width = width, height = height,
                gp = gpar(fill = col, col = "black", lwd = 0.5))
    }
  )
  
  return(ht)
}


# Get all unique clusters
all_clusters <- unique(presence_matrices$cluster)

# Generate heatmaps for each cluster
heatmap_list <- lapply(all_clusters, plot_cluster_heatmap)
# Get all unique clusters
all_clusters <- unique(presence_matrices$cluster)

plot_cluster_heatmap("EEC")
```

```{r}
for (cluster_name in all_clusters) {
  p <- plot_cluster_heatmap(cluster_name = cluster_name, 
                            color_palette = uninf_cols)
  size <- calc_ht_size(p)

  # sanitize cluster_name for safe filenames
  safe_name <- gsub("[/\\\\:*?\"<>|]", "_", cluster_name)

  save_ggplot_formats(
    plt = p,
    base_plot_dir = plots_folder,
    plt_name = glue("presence_absence_tf_{safe_name}_color"),
    width = size[1], height = size[2],
    plot_obj = "heatmap"
  )
}
```
