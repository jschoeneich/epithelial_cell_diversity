---
title: "DE_GO_RNA_seq_promedi"
author: "Johannes Schöneich"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
library(EnhancedVolcano)
library(tidyverse)
library(DESeq2)
library(limma)
library(glue)
library(clusterProfiler)
library(DOSE)
library(enrichplot)
library(patchwork)
library(cowplot)
library(openxlsx)
library(scales)
library(ggpubr)
library(pbapply)

harddrive <- "H:/231248/NTFS_3.64TB"

source(file.path(harddrive,"helper_functions.R"))
source(file.path(harddrive,"/DE_analysis/DE_helperfunctions.R"))
```

```{r}
dds_fullsample <- readRDS(file.path(harddrive,
                                    "RNA_seq/RNAseq_promedi/dds_LRT_group_RNAseq_promedi.Rds"))

#condition to analyse: e.g. timepoint, condition
condition <- "group"

analysis_folder <- glue("DE_analysis/DE_LRT_promedi_{condition}")

plots_folder <- file.path(harddrive,analysis_folder,"DE/plots")
charts_folder <- file.path(harddrive,analysis_folder,"DE/charts")

if (!dir.exists(analysis_folder)){
  dir.create(analysis_folder,recursive = TRUE)
  dir.create(plots_folder,recursive = TRUE)
  dir.create(charts_folder,recursive = TRUE)
}

#optional: read in the results.list if this analysis was already run and you want to change plots

results.list_switched <- readRDS(file.path(harddrive,analysis_folder,                                                                     glue("DE_results.list_{condition}_switched.Rds")))

results.list <- readRDS(file.path(harddrive,analysis_folder,
                                  glue("DE_results.list_{condition}.Rds")))

```

## Volcano Plots DE genes

The contrast order is always +logFC then -logFC 
(first numerator (Zähler) then Denominator (Nenner))
condition treated vs untreated, tells you that the estimates are of the 
logarithmic fold change log2(treated/untreated).

The level given last is the base level for the comparison. The syntax is:
contrast <- c("condition", "level_to_compare", "base_level")
for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower 
in the level of interest relative to the base level

```{r, warning = FALSE}
#every pairwise combination of timepoints
combination <- combn(levels(colData(dds_fullsample)[,condition]), 2)
#catch the error if underscore is used in the name
#combination <- gsub("_","-",combination)

combination_switch <- combination[c(2,1),] # make it so that prox is always left
#careful. This works for pro vs med vs dis same age, but screws up intra location

#in the case of prWe/poWe we want the early timepoints to be in front
#levels.sort <- sort(levels(colData(dds_fullsample)[,condition]),decreasing = T)
#combination <- combn(levels.sort,2)

list.names <- capture.output(apply(combination_switch,2,
                                   function(x){cat(x,sep = "_",fill = TRUE)}))
list.names <- list.names[which(list.names!="NULL")]

if(!exists("results.list")){
  #make an empty list with all combinations
  results.list <- sapply(list.names,function(x) NULL)

for(i in 1:length(results.list)){
  print(i)
  #paste("working on", list.names[i])
  results.list[[i]] <- results(dds_fullsample, 
                               contrast = c(condition, 
                                            combination_switch[1,i],
                                            combination_switch[2,i]),
                               cooksCutoff = TRUE,
                               independentFiltering = TRUE, 
                               alpha = 0.05, 
                               pAdjustMethod = "BH"
                               )

  results.list[[i]] <- lfcShrink(dds_fullsample, 
                                 contrast = c(condition, 
                                              combination_switch[1,i], 
                                              combination_switch[2,i]),
                                 res = results.list[[i]],
                                 type = "ashr")
}

results.list <- lapply(results.list,function(x){x$symbol <- rownames(x);return(x)})
sapply(results.list,function(x){sum(is.na(x))}) #are there any NAs left?
results.list <- lapply(results.list,function(x){na.omit(x)})

#change logfc so that early is to the left.
results.list <- lapply(results.list,
                       function(res){
                         res$log2FoldChange <- -res$log2FoldChange
                         return(res)
                         }
                       )

saveRDS(results.list,file = file.path(harddrive,
                                      analysis_folder,
                                      glue("DE_results.list_",
                                           "{condition}_switched.Rds")))
}
```

```{r}
# Define the timepoints and categories
timepoints <- c("d01", "d05", "d10", "d25")
categories <- c("pro", "med", "dis")

# Generate all pairwise comparisons
all_comparisons <- unlist(
  lapply(timepoints, function(tp) {
    paste0(tp, ".", categories[-length(categories)], "_", tp, ".", categories[-1])
  })
)

# Print the result
print(all_comparisons)
```


```{r}
#for the version with pro in the front comparison
generate_volcano_plots(results_list = results.list_switched,
                       pos_color = "#E41A1C",
                       neg_color = "#377EB8",
                       plots_folder = plots_folder,
                       charts_folder = charts_folder,
                       filename_prefix = "promedi_paper_v5",
                       save = TRUE,
                       subset_condition = all_comparisons
                       )
```

```{r}
# promedi intra
# Define the timepoints
timepoints <- c("d01", "d05", "d10", "d25")

# Define the conditions
conditions <- c("pro", "med", "dis")

# Generate reversed-order vectors for each condition
pro_vector <- paste0(timepoints[-length(timepoints)], ".pro_",
                     timepoints[-1], ".pro")
med_vector <- paste0(timepoints[-length(timepoints)], ".med_",
                     timepoints[-1], ".med")
dis_vector <- paste0(timepoints[-length(timepoints)], ".dis_", 
                     timepoints[-1], ".dis")
```

```{r}
generate_volcano_plots(results_list = results.list,
                       pos_color = "#E41A1C",
                       neg_color = "#377EB8",
                       plots_folder = plots_folder,
                       charts_folder = charts_folder,
                       filename_prefix = "promedi_pro_intra",
                       save = TRUE,
                       subset_condition = pro_vector
                       )

generate_volcano_plots(results_list = results.list,
                       pos_color = "#E41A1C",
                       neg_color = "#377EB8",
                       plots_folder = plots_folder,
                       charts_folder = charts_folder,
                       filename_prefix = "promedi_med_intra",
                       save = TRUE,
                       subset_condition = med_vector
                       )

generate_volcano_plots(results_list = results.list,
                       pos_color = "#E41A1C",
                       neg_color = "#377EB8",
                       plots_folder = plots_folder,
                       charts_folder = charts_folder,
                       filename_prefix = "promedi_dis_intra",
                       save = TRUE,
                       subset_condition = dis_vector
                       )
```

# Promedi correlation analysis
```{r}
# We take DE genes. 
# And we combine signature genes: 
# DE medial vs proximal and DE medial vs distal | 
# DE proximals vs medial DE prorximal vs distal | 
# DE distal vs medial DE distal vs proximal (all d25)
# 
# then we use the variance stabilized counts (vst) 
# from the top X [20-100, best 50+] 
# signature genes in d25 [pmd] and do a cross-correlation against d01|d05|d10|d25 separate

vst_mat <- assay(vst(dds_fullsample))
coldata <- as.data.frame(colData(dds_fullsample))

# Average per gene/timepoint/location
avg_expr <- vst_mat %>%
  as.data.frame() %>%
  tibble::rownames_to_column("gene") %>%
  pivot_longer(-gene, names_to = "sample", values_to = "expr") %>%
  left_join(coldata, by = c("sample" = "sample_name")) %>%
  group_by(gene, timepoint, location) %>%
  summarise(mean_expr = mean(expr), .groups = "drop")
```

```{r}
# Get top DE genes for each intestinal zone
prepare_gene_sets <- function(results.list_switched, 
                              max_num_genes = 100, 
                              filter_criterium = "padj", 
                              l2fc_filter = 1,
                              extract_genes = TRUE) {
  
  # Filter by significance and fold change
  res_filter <- lapply(results.list_switched, function(df) {
    df %>%
      as.data.frame() %>%
      filter(abs(log2FoldChange) >= l2fc_filter & padj < 0.05)
  })
  
  # Sorting function
  sort_fun <- if (filter_criterium == "padj") {
    function(df) arrange(df, padj)
  } else {
    function(df) arrange(df, desc(abs(log2FoldChange)))
  }
  
  # Pre-filtered and sorted lists
  pro_all <- bind_rows(
    res_filter$d25.pro_d25.med %>% filter(log2FoldChange <= -l2fc_filter),
    res_filter$d25.pro_d25.dis %>% filter(log2FoldChange <= -l2fc_filter)
  ) %>% sort_fun() %>% distinct(symbol, .keep_all = TRUE)
  
  med_all <- bind_rows(
    res_filter$d25.pro_d25.med %>% filter(log2FoldChange >= l2fc_filter),
    res_filter$d25.med_d25.dis %>% filter(log2FoldChange <= -l2fc_filter)
  ) %>% sort_fun() %>% distinct(symbol, .keep_all = TRUE)
  
  dis_all <- bind_rows(
    res_filter$d25.med_d25.dis %>% filter(log2FoldChange >= l2fc_filter),
    res_filter$d25.pro_d25.dis %>% filter(log2FoldChange >= l2fc_filter)
  ) %>% sort_fun() %>% distinct(symbol, .keep_all = TRUE)
  
  # Remove overlaps between gene lists before slicing
  pro_unique <- pro_all %>%
    filter(!symbol %in% med_all$symbol, !symbol %in% dis_all$symbol)
  
  med_unique <- med_all %>%
    filter(!symbol %in% pro_all$symbol, !symbol %in% dis_all$symbol)
  
  dis_unique <- dis_all %>%
    filter(!symbol %in% pro_all$symbol, !symbol %in% med_all$symbol)
  
  # Select top N from the unique sets
  # EDIT: we changed to non-unique
  
  if(extract_genes == TRUE){
  pro_d25 <- pro_all %>% slice_head(n = max_num_genes) %>% pull(symbol)
  med_d25 <- med_all %>% slice_head(n = max_num_genes) %>% pull(symbol)
  dis_d25 <- dis_all %>% slice_head(n = max_num_genes) %>% pull(symbol)
  } else{
  pro_d25 <- pro_all %>% slice_head(n = max_num_genes)
  med_d25 <- med_all %>% slice_head(n = max_num_genes)
  dis_d25 <- dis_all %>% slice_head(n = max_num_genes)
  }
  
  return(list(pro = pro_d25, med = med_d25, dis = dis_d25))
}

# Correlations within the same zone (e.g. pro, med, dis)

plot_zone_correlations <- function(avg_expr, gene_sets, vst_counts,
                                   filter_criterium = "padj", 
                                   max_num_genes = 100,
                                   plot_title = TRUE,
                                   plot_name = "promedi_d25_correlation",
                                   save_counts = TRUE) {
  
  color_values <- c("d01" = "#E08B00", "d05" = "#5BB300", 
                    "d10" = "#7997FF", "d25" = "#FF61C9")
  tps <- c("d01", "d05", "d10", "d25")
  
  plot_correlations <- function(zone, gene_set) {
    dat <- avg_expr %>%
      filter(location == zone, gene %in% gene_set) %>%
      pivot_wider(names_from = timepoint, values_from = mean_expr)
    
    lapply(tps, function(tp) {
      df <- dat %>%
        select(gene, !!tp) %>%
        rename(x = !!tp) %>%
        mutate(y = dat$d25)
      
      rho <- cor(df$x,
                 df$y,
                 method = "spearman",
                 use = "pairwise.complete.obs")
      
      ggplot(df, aes(x = x, y = y)) +
        geom_point(color = color_values[tp], size = 0.25, alpha = 0.8) +
        geom_smooth(method = "lm",
                    color = "#E34A33", 
                    linewidth = 0.5,
                    se = FALSE, 
                    linetype = "dashed") +
        annotate("text", 
                 x = min(df$x, na.rm = TRUE),
                 y = max(df$y, na.rm = TRUE),
                 label = paste0("rho = ", round(rho, 2)),
                 hjust = 0, 
                 vjust = 1,
                 size = 2,
                 color = "black") +
        labs(
          x = tp,
          y = "d25",
          title = if (plot_title) paste(zone, tp, "vs d25") else NULL
        ) +
        scale_x_continuous(breaks = pretty_breaks(n = 4)) +
        scale_y_continuous(breaks = pretty_breaks(n = 4)) +
        theme_classic(base_size = 7) +
        theme(
          axis.text = element_text(size = 7, color = "black"),
          axis.title = element_text(size = 7, color = "black"),
          plot.title = element_text(size = 7, face = "bold", color = "black"),
          axis.ticks = element_blank(),
          axis.text.x = element_text(margin = margin(t = -0.5)),
          axis.text.y = element_text(margin = margin(r = -0.5))
        )
    })
  }
  
  zone_plots <- lapply(names(gene_sets), function(zone){
    plot_correlations(zone, gene_sets[[zone]])
    }
    )
  
  names(zone_plots) <- names(gene_sets)
  
  all_plots <- c(zone_plots$pro, zone_plots$med, zone_plots$dis)
  
  # Adjust plot size based on title presence
  ncol <- 4
  nrow <- 3
  width <- ncol * 1.1 + 0.5
  height <- nrow * (if (plot_title) 1.1 else 0.95) + 0.2
  
  combined <- ggarrange(plotlist = all_plots, ncol = ncol, nrow = nrow)
  
  final_name <- glue("{plot_name}_{filter_criterium}_",
                     "filter_top{max_num_genes}_",
                     "{ifelse(plot_title, 'title', 'no_title')}"
  )
  
  save_ggplot_formats(combined,
                      base_plot_dir = plots_folder, 
                      plt_name = final_name, 
                      width = width,
                      height = height)
  
  #Optionally save VST counts used for the figure
  if (save_counts) {
  wb <- createWorkbook()
  zone_order <- c("pro", "med", "dis")  # consistent order of regions
  tp_order <- c("d01", "d05", "d10", "d25")  # consistent order of timepoints
  
  for (zone in zone_order) {
    genes <- gene_sets[[zone]]
    zone_counts <- vst_counts[genes, , drop = FALSE]
    
    # Reorder columns: first by zone (pro → med → dis), 
    # then by timepoint (d01 → d25)
    ordered_cols <- unlist(lapply(zone_order, function(z) {
      grep(z, colnames(zone_counts), value = TRUE)
    }))
    
    # Within each zone, order by timepoint
    ordered_cols <- unlist(lapply(ordered_cols, function(colgroup) {
      sort(colgroup, method = "radix")
    }))
    
    # Ensure we only keep existing columns in case some are missing
    zone_counts <- zone_counts[, intersect(ordered_cols,
                                           colnames(zone_counts)),
                               drop = FALSE]
    
    addWorksheet(wb, zone)
    writeData(wb, zone, as.data.frame(zone_counts), rowNames = TRUE)
  }
  
  saveWorkbook(
    wb,
    file = file.path(plots_folder, glue("{final_name}_vst_counts.xlsx")),
    overwrite = TRUE
  )
}
  combined
}


# Correlations between zones (e.g. pro vs med, med vs dis, etc.)

plot_cross_zone_correlations <- function(avg_expr, gene_sets, vst_counts,
                                         filter_criterium = "padj",
                                         max_num_genes = 100,
                                         plot_title = FALSE,
                                         plot_name =
                                           "promedi_crosszone_correlation",
                                         save_counts = TRUE) {
  
  zones <- c("pro", "med", "dis")
  tps <- c("d01", "d05", "d10", "d25")
  color_values <- c("d01" = "#E08B00", "d05" = "#5BB300", 
                    "d10" = "#7997FF", "d25" = "#FF61C9")
  
  plot_cross <- function(src, tgt, gene_set) {
    src_dat <- avg_expr %>%
      filter(location == src, gene %in% gene_set) %>%
      pivot_wider(names_from = timepoint, values_from = mean_expr)
    
    tgt_dat <- avg_expr %>%
      filter(location == tgt, gene %in% gene_set) %>%
      pivot_wider(names_from = timepoint, values_from = mean_expr)
    
    lapply(tps, function(tp) {
      df <- data.frame(x = src_dat[[tp]], y = tgt_dat[["d25"]])
      rho <- cor(df$x, df$y, method = "spearman", 
                 use = "pairwise.complete.obs")
      
      ggplot(df, aes(x = x, y = y)) +
        geom_point(color = color_values[tp], size = 0.25, alpha = 0.8) +
        geom_smooth(method = "lm", color = "#E34A33", linewidth = 0.5, 
                    se = FALSE, 
                    linetype = "dashed") +
        annotate("text", x = min(df$x, na.rm = TRUE), y = max(df$y, 
                                                              na.rm = TRUE),
                 label = paste0("rho = ", round(rho, 2)), hjust = 0, 
                 vjust = 1, size = 2) +
        labs(
          x = paste(src, tp),
          y = paste(tgt, "d25"),
          title = if (plot_title) paste(src, tp, "vs", tgt, "d25") else NULL
        ) +
        scale_x_continuous(breaks = pretty_breaks(n = 4)) +
        scale_y_continuous(breaks = pretty_breaks(n = 4)) +
        theme_classic(base_size = 7) +
        theme(
          axis.text = element_text(size = 7, color = "black"),
          axis.title = element_text(size = 7, color = "black"),
          plot.title = element_text(size = 7, face = "bold", color = "black"),
          axis.ticks = element_blank(),
          axis.text.x = element_text(margin = margin(t = -0.5)),
          axis.text.y = element_text(margin = margin(r = -0.5))
        )
    })
  }
  
  # Build all combinations in pro → med → dis order
  cross_plots <- list()
  for (src in zones) {
    for (tgt in zones) {
      if (src != tgt) {
        cross_plots[[paste(src, "vs", tgt, sep = "_")]] <- 
          plot_cross(src, tgt, gene_sets[[src]])
      }
    }
  }
  
  all_plots <- unlist(cross_plots, recursive = FALSE)
  
  ncol <- 4
  nrow <- 6
  width <- ncol * 1.1 + 0.5
  height <- nrow * (if (plot_title) 1.1 else 0.95) + 0.2
  
  combined <- ggarrange(plotlist = all_plots, ncol = ncol, nrow = nrow)
  
  final_name <- glue("{plot_name}_{filter_criterium}_",
  "filter_top{max_num_genes}_",
  "{ifelse(plot_title, 'title', 'no_title')}")
  
  save_ggplot_formats(combined, 
                      base_plot_dir = plots_folder, 
                      plt_name = final_name, 
                      width = width, 
                      height = height)
  
if (save_counts) {
  wb <- createWorkbook()
  zone_order <- c("pro", "med", "dis")
  
  for (src in zone_order) {
    for (tgt in zone_order) {
      if (src != tgt) {
        genes <- gene_sets[[src]]
        sub_counts <- vst_counts[genes, , drop = FALSE]
        
        # reorder columns by zone order if sample names contain 
        # "pro", "med", "dis"
        ordered_cols <- unlist(lapply(zone_order, function(z) {
          grep(z, colnames(sub_counts), value = TRUE)
        }))
        
        sub_counts <- sub_counts[, intersect(ordered_cols, 
                                             colnames(sub_counts)), 
                                 drop = FALSE]
        
        sheet_name <- paste0(src, "_vs_", tgt)
        addWorksheet(wb, sheet_name)
        writeData(wb, sheet_name, as.data.frame(sub_counts), rowNames = TRUE)
      }
    }
  }
  
  saveWorkbook(
    wb,
    file = file.path(plots_folder, 
                     glue("{final_name}_vst_counts.xlsx")
                     ),
    overwrite = TRUE
  )
}
  combined
}

```

```{r}
plots_folder <- file.path(plots_folder,"promedi_correlation/all_unique")
dir.create(plots_folder)
```

```{r}
# Define all parameter options
param_grid <- expand.grid(
  max_num_genes = 50,
  filter_criterium = "padj",
  plot_title = c(TRUE, FALSE),
  stringsAsFactors = FALSE
)

# Function to run one combination
process_combination <- function(params_row) {
  
  params <- params_row
  
  cat("Processing combination:", 
      "max_genes =", params$max_num_genes, 
      ", filter_criterium =", params$filter_criterium, 
      ", plot_title =", params$plot_title, "\n")
  
  # Prepare gene sets
  gene_sets <- prepare_gene_sets(
    results.list_switched,
    max_num_genes = params$max_num_genes,
    filter_criterium = params$filter_criterium
  )
  
  # Base name for files/plots
  base_name <- glue::glue(
    "max{params$max_num_genes}_{params$filter_criterium}_",
    "{ifelse(params$plot_title, 
    'title', 'no_title')}"
  )
  
  # Within-zone correlations
  plot_zone_correlations(
    avg_expr = avg_expr,
    gene_sets = gene_sets,
    vst_counts = vst_mat,
    filter_criterium = params$filter_criterium,
    max_num_genes = params$max_num_genes,
    plot_title = params$plot_title,
    plot_name = glue::glue("promedi_d25_correlation_new3"),
    save_counts = TRUE,
    save_rho_heatmap = TRUE,
    plots_folder = my_plots_folder
  )
  
  # # Cross-zone correlations
  # plot_cross_zone_correlations(
  #   avg_expr = avg_expr,
  #   gene_sets = gene_sets,
  #   vst_counts = vst_mat,
  #   filter_criterium = params$filter_criterium,
  #   max_num_genes = params$max_num_genes,
  #   plot_title = params$plot_title,
  #   plot_name = glue::glue("promedi_crosszone_correlation"),
  #   save_counts = FALSE
  # )
}

# Use pbapply to iterate over all rows with a progress bar (Windows-safe)
pblapply(seq_len(nrow(param_grid)), function(i) {
  process_combination(param_grid[i, ])
})

```


```{r}
#heatmap of all DE genes of pro/med/dis

d25_list <- prepare_gene_sets(
    results.list_switched,
    max_num_genes = 50,
    filter_criterium = "padj"
  )


d25_list_df <- prepare_gene_sets(
    results.list_switched,
    max_num_genes = 50,
    filter_criterium = "padj",
    extract_genes = FALSE
  )

# Convert Gene Symbols to Descriptions
data_subset_list <- lapply(d25_list_df,function(gene_data){
  convert_gene_symbols(gene_data$symbol)

# Merge the descriptions back into the original data
gene_data <- left_join(gene_data, gene_info, 
                       by = c("symbol" = "gene_name"))

data_subset <- gene_data[c("symbol","description","log2FoldChange","padj")]
data_subset <- unique(data_subset)
return(data_subset)
})

write.xlsx(data_subset_list,file.path(charts_folder,"promedi_correlation_list.xlsx"))

d25_list_full <- prepare_gene_sets(
    results.list_switched,
    max_num_genes = Inf,
    filter_criterium = "padj"
  )

genes <- unlist(d25_list,use.names = FALSE)

# subset to your genes
mat <- vst_mat[unique(genes), , drop = FALSE]
mat <- mat[,grep("d25",colnames(mat))]

# z-score per gene
mat_scaled <- t(scale(t(mat)))

# Example breaks
breaks <- c(-2,-1,0,1,2)

# Viridis palette with 3 colors (or more)
col_fun <- colorRamp2(
  breaks,
  viridisLite::viridis(length(breaks))
)

desired_order <- c("pro", "med", "dis")

col_order <- order(
  factor(
    stringr::str_extract(colnames(mat), "pro|med|dis"),
    levels = desired_order
  )
)

mat_scaled <- mat_scaled[, col_order]

  gene_peak_bin <- max.col(mat_scaled, ties.method = "first")
    gene_order <- order(gene_peak_bin)
    
    avg_scaled_ordered <- mat_scaled[gene_order, ]
    
    mat_clean <- avg_scaled_ordered
    
    # Remove rows that are all NA
    mat_clean <- mat_clean[rowSums(is.na(mat_clean)) == 0, ]
    
    # Remove rows with zero variance (constant expression)
    mat_clean <- mat_clean[apply(mat_clean, 1, sd, na.rm = TRUE) > 0, ]
    
    # Replace NaN or Inf
    mat_clean[!is.finite(mat_clean)] <- 0


# Heatmap
hm_full <- Heatmap(
  mat_clean,
  name = "z-score",
  col = col_fun,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 6)
)

save_ggplot_formats(plt = hm_full, 
                      base_plot_dir = plots_folder, 
                      create_plot_subdir = TRUE,
                      plot_obj = "heatmap",
                      plt_name = 
                      "heatmap_all_promedi_d25_DE-genes_top50_viridis3",
                      width = 3, 
                      height = 9
                    )
```

```{r}
plot_zone_correlations <- function(
    avg_expr,
    gene_sets,
    vst_counts,
    filter_criterium,
    max_num_genes,
    plot_title = TRUE,
    plot_name = "zone_corr",
    save_counts = FALSE,
    save_rho_heatmap = FALSE,
    plots_folder = "."
) {
  
  # Colors for points
  color_values <- c("d01" = "#E08B00", "d05" = "#5BB300",
                    "d10" = "#7997FF", "d25" = "#FF61C9")
  
  # Save all computed rho values here
  rho_mat <- matrix(NA, nrow = 3, ncol = 4,
                    dimnames = list(c("pro","med","dis"),
                                    c("d01","d05","d10","d25")))
  
  zone_plots <- list()
  
  # Loop through zones (pro/med/dis)
  for (zone in names(gene_sets)) {
    
    genes <- gene_sets[[zone]]
    
    dat <- avg_expr %>%
      filter(location == zone, gene %in% genes) %>%
      pivot_wider(names_from = timepoint, values_from = mean_expr)
    
    tps <- c("d01","d05","d10","d25")
    
    zone_plots[[zone]] <- map(tps, function(tp) {
      
      df <- dat %>%
        select(gene, !!tp) %>%
        rename(x = !!tp) %>%
        mutate(y = dat$d25,
               timepoint = tp)
      
      rho <- cor(df$x, df$y, method = "spearman",
                 use = "pairwise.complete.obs")
      
      # Store rho value
      rho_mat[zone, tp] <<- rho
      
      ggplot(df, aes(x = x, y = y)) +
        geom_point(color = color_values[tp], size = 0.25, alpha = 0.8) +
        geom_smooth(method = "lm", color = "#E34A33",
                    linewidth = 0.5, se = FALSE, linetype = "dashed") +
        annotate("text",
                 x = min(df$x, na.rm = TRUE),
                 y = max(df$y, na.rm = TRUE),
                 label = paste0("rho = ", round(rho, 2)),
                 hjust = 0, vjust = 1, size = 2) +
        labs(
          x = tp,
          y = "d25",
          title = if (plot_title) paste(zone, tp, "vs d25") else NULL
        ) +
        scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
        scale_y_continuous(breaks = scales::pretty_breaks(n = 4)) +
        theme_classic(base_size = 7) +
        theme(
          axis.text = element_text(color = "black", size = 7),
          axis.title = element_text(color = "black", size = 7),
          plot.title = element_text(color = "black", size = 7, face = "bold"),
          axis.ticks = element_blank(),
          axis.text.x = element_text(margin = margin(t = -0.5)),
          axis.text.y = element_text(margin = margin(r = -0.5))
        )
    })
    
    names(zone_plots[[zone]]) <- tps
  }
  
  all_plots <- unlist(zone_plots, recursive = FALSE)
  
  final_name <- glue("{plot_name}_{filter_criterium}_filter_top{max_num_genes}_{if (plot_title) 'title' else 'no_title'}")
  
  # Auto-size panels (same logic as before)
  width <- 4
  height <- 3
  
  correlation_plots <- ggpubr::ggarrange(
    plotlist = all_plots,
    ncol = 4,
    nrow = 3
  )
  
  save_ggplot_formats(
    plt = correlation_plots,
    base_plot_dir = plots_folder,
    plt_name = final_name,
    width = width,
    height = height
  )
  
  # Save VST counts ------------------------------------------------------------
  if (save_counts) {
    wb <- createWorkbook()
    zone_order <- c("pro", "med", "dis")  # consistent order of regions
    tp_order <- c("d01", "d05", "d10", "d25")  # consistent order of timepoints
    
    for (zone in zone_order) {
      genes <- gene_sets[[zone]]
      zone_counts <- vst_counts[genes, , drop = FALSE]
      
      # Reorder columns: first by zone (pro → med → dis), 
      # then by timepoint (d01 → d25)
      ordered_cols <- unlist(lapply(zone_order, function(z) {
        grep(z, colnames(zone_counts), value = TRUE)
      }))
      
      # Within each zone, order by timepoint
      ordered_cols <- unlist(lapply(ordered_cols, function(colgroup) {
        sort(colgroup, method = "radix")
      }))
      
      # Ensure we only keep existing columns in case some are missing
      zone_counts <- zone_counts[, intersect(ordered_cols,
                                             colnames(zone_counts)),
                                 drop = FALSE]
      
      addWorksheet(wb, zone)
      writeData(wb, zone, as.data.frame(zone_counts), rowNames = TRUE)
    }
    
    saveWorkbook(
      wb,
      file = file.path(plots_folder, glue("{final_name}_vst_counts.xlsx")),
      overwrite = TRUE
    )
  }
  # Save rho heatmap ------------------------------------------------------------
  if (save_rho_heatmap) {
    
    col_fun <- circlize::colorRamp2(
      c(-1, 0, 1),
      c("navy", "white", "firebrick3")
    )
    
    # Add value labels inside cells
    cell_fun <- function(j, i, x, y, w, h, fill) {
      grid::grid.text(
        sprintf("%.2f", rho_mat[i, j]),
        x = x, y = y,
        gp = grid::gpar(fontsize = 8, col = "black")
      )
    }
    
    hm <- ComplexHeatmap::Heatmap(
      rho_mat,
      name = "rho",
      col = col_fun,
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      cell_fun = cell_fun,
      show_row_names = TRUE,
      show_column_names = TRUE
    )
    
    save_ggplot_formats(
      plt = hm,
      plt_name = glue("{final_name}_rho_heatmap"),
      base_plot_dir = plots_folder,
      plot_obj = "heatmap",
      width = 3,
      height = 2
    )
  }
  invisible(rho_mat)
}

my_plots_folder=plots_folder
# Within-zone correlations
plot_zone_correlations(
  avg_expr = avg_expr,
  gene_sets = gene_sets,
  vst_counts = vst_mat,
  filter_criterium = filter_criterium,
  max_num_genes = max_num_genes,
  plot_title = TRUE,
  plot_name = glue::glue("promedi_d25_correlation_new_50_padj2"),
  save_counts = FALSE,
  save_rho_heatmap = TRUE,
  plots_folder = my_plots_folder
)

```




